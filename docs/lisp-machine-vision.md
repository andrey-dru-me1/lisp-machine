# Lisp Machine Vision

Конечным продуктом должна являться программа, которая осуществляет трансляцию **синтетического статически типизированного Lisp‑подобного языка**, основанного на идеях базового Lisp, **на язык Rust**.

---

## Конечный продукт

Конечный продукт должен состоять из следующих компонентов:

- Программа‑транслятор (написанная на Rust);
- Документация по её использованию;
- Описание синтетического статически типизированного Lisp‑подобного языка, считываемого программой‑транслятором.

---

## Базовый функционал

### 1. Базовая программа‑транслятор

- Программа представляет собой консольную утилиту, реализованную на языке **Rust**.
- На вход она принимает путь до файла, содержащего исходный код на **синтетическом статически типизированном Lisp‑подобном языке**.
- На выходе она формирует файл с исходным кодом на языке **Rust**.
- Компиляция сгенерированного Rust‑кода и запуск скомпилированной программы должны по семантике соответствовать исходной программе на Lisp‑подобном языке (с учётом его статической типизации).

#### Требования к трансляции

- Язык‑источник является:
  - **S‑expression‑языком**, синтаксически близким к базовому Lisp;
  - **статически типизированным**:
    - наличие объявлений типов (или вывод типов на этапе трансляции);
    - наличие базовых типов (например: `Int`, `Float`, `Bool`, `String`, возможно, `List<T>`, `Option<T>` и т.п.);
    - наличие механизма проверки типов на этапе трансляции и генерации сообщений об ошибках типов.
- Транслятор должен:
  - разбирать входной файл (парсинг S‑выражений);
  - строить внутреннее представление программы (AST);
  - выполнять проверку типов и других статических ограничений;
  - генерировать корректный Rust‑код (c маппингом типов и конструкций языка на Rust).

---

### 2. Базовая документация использования программы‑транслятора

В документации к программе должны присутствовать разделы:

- **Установка**:
  - способы установки консольной утилиты (сборка из исходников на Rust, возможная установка через пакетный менеджер и т.п.);
  - системные требования (версия Rust toolchain, ОС и т.д.).
- **Использование**:
  - порядок передачи параметров программе (например: `lisp_mv_transpiler input.lmv -o output.rs`);
  - предварительные условия, необходимые для запуска (установленный Rust, права на запись результата и т.п.);
  - набор доступных опций и параметризованных опций с пояснениями, например:
    - `-o, --output <FILE>` — путь к выходному файлу с Rust‑кодом;
    - `--emit-exe` — опциональная двухэтапная компиляция до исполняемого файла;
    - `--check` — только проверка типов и синтаксиса без генерации кода;
    - `-h, --help` — вывод встроенной справки.

---

### 3. Базовое описание Lisp‑подобного языка

В рамках данного проекта используется **собственный синтетический Lisp‑подобный язык** со следующими ключевыми особенностями:

1. **Основан на базовом Lisp‑синтаксисе**:
   - код представлен в виде S‑выражений в префиксной записи;
   - поддерживаются стандартные лиспоподобные конструкции (функции, условные выражения, базовые операции и т.п.).

2. **Статическая типизация**:
   - язык обладает **явной моделью типов**;
   - каждая функция и переменная имеют статически определённый тип;
   - типы проверяются на этапе работы транслятора;
   - возможна поддержка вывода типов (опционально, по дизайну языка);
   - описывается набор встроенных типов и правил их взаимодействия.

3. **Документация языка** должна содержать:
   - описание синтаксиса (формальное или полуформальное, например в виде BNF/EBNF для S‑выражений плюс правила для аннотаций типов);
   - описание системы типов:
     - перечень базовых типов;
     - правила приведения типов (если предусмотрены);
     - правила типизации выражений и функций;
   - описание семантики основных конструкций:
     - объявления переменных и функций;
     - вызов функций;
     - условные выражения;
     - базовые операции над числами, логические операции, операции со строками и коллекциями;
   - правила соответствия конструкций языка целевому коду на Rust (какие типы и конструкции во что транслируются).

---

## Возможные расширения

### 1. Расширение программы‑транслятора

1. **Двухэтапная компиляция до исполняемого файла**  
   Добавить режим, при котором транслятор:
   - сначала генерирует Rust‑код;
   - затем автоматически вызывает `rustc` (или `cargo`) для компиляции в исполняемый файл;
   - на выходе пользователь сразу получает готовый к запуску бинарник.

2. **REPL‑интерпретатор**  
   Добавить REPL‑режим для языка:
   - интерактивный ввод выражений на синтетическом Lisp‑языке;
   - немедленное выполнение или интерпретация (возможен JIT‑подобный подход через генерацию и запуск временного Rust‑кода, либо отдельный интерпретатор на Rust);
   - вывод результатов, сообщений об ошибках типов и синтаксиса.

3. **Отладка программ**  
   Добавить возможности отладки:
   - вывод промежуточного AST или типовой информации;
   - режим подробных логов трансляции;
   - (опционально) генерация Rust‑кода с отладочными макросами (`dbg!`, логирование) для отслеживания исполнения сгенерированной программы.

---

### 2. Расширение документации

- Встроить краткую документацию непосредственно в консольную утилиту:
  - опция `-h`/`--help` для отображения справки по использованию;
  - опция, отображающая краткое описание синтаксиса и системы типов языка (например, `--lang-help`);
  - ссылки на полную документацию (онлайн или локально).

---

### 3. Расширение описания Lisp‑подобного языка

- Расширить документацию языка **набором примерных программ**:
  - простые программы (арифметика, рекурсивные функции, использование условных выражений);
  - примеры, демонстрирующие систему типов (ошибки типов, параметризованные типы, полиморфизм — если он будет реализован);
  - более сложные примеры, пригодные как для тестирования транслятора, так и в качестве учебных кейсов.
- Эти же программы использовать как **набор автоматизированных тестов** для проверки корректности работы транслятора и соответствия сгенерированного Rust‑кода ожидаемому поведению.
